
<h1 align="center"> Если вам попались вопросв - которых не было пишите мне в личные сообщения в тг </h1>

### SOLID and STUPID 
Меня спросили я тупо рассказал все про SOLID( насчет STUPID меня не спросили хотя вроде вайб )

1) В каком случае буква L в SOLID может быть нарушенна?

<details>
  <summary>Ответ</summary>

Может быть нарушена к примеру когда дочери добавляем логику обработки ошибки
```java
class Parent{
    public void doSmth(){}
}
class Rebenok extends Parent{
    public void doSmth(){
        try {
            System.out.println("Ну да я пишу дочь");
        }catch (Exception ignore){
            System.out.println("Вот тут логика и нарушается");
        }
    }
}

```
</details>



## equals HashCode

1) Для чего нужны эти методы?
2) Что возвращают по умолчанию?
3) Для чего нужно их переопределние?
4) Что мы должны гарнтировать когда переопределяем эти методы? 
5) Предположим есть: 
         Дано: массив с длинной 1^10 элемментов + какой то эллемент
         Найти этот элемент в массиве
         Это вам поможет понять роль equals и HashCode
6) Что такое коллизия в HashCode ? 
7) Как ее решать ?
<details>
  <summary>1)Ответ</summary>
Они реализуют одну и ту же логику - "являются ли два объекта одним и тем же". Однако делают это абсолютно по разному.

Если супер коротко - то HashCode сравнивает довольно быстро но разные объекты могут иметь одинаковый "номер".
Equals делает это очччччеееень долго но может гарантировать, что объекты сто проц равны

</details>
<details>
  <summary>2)Ответ</summary>
HashCode - хэширует все поля и выдает в int
Equals - объекты лешат в памяти в одном месте (но ваще он делает obj.clone() == obj )  
</details>
<details>
  <summary>3)Ответ</summary>
Когда мы ходим их переопределить - и к примеру сделать логику сравнения(хэширования) через какое-то поле

</details>
<details>
  <summary>4)Ответ</summary>

1) null != null
2) x == y => y == x
3) x==y ; y==z => x==z
4) x==x

Реферсивность,
транзитивность, 
ассоциативность

Закономерный ответ когда это может быть нарушенно - оставляем в качестве упражнения)
</details>

<details>
  <summary>5) Ответ</summary>

Вот тут тип и можно понять для чего нужен hashCode и equals и в чем их разница 

Мы пробегаемся по массиву и сравниваем их **hashCode** - но тут проблема у разных объектов **hashCode** могут быть равен
Вот тут и приходит на помощь equals 

Если бы мы начали все объекты с помощью equals то это было бы долго

</details>

<details>
  <summary>6) Ответ</summary>

Собсна в прошлом ответе поднимался этот вопрос - ну тип когда у неодинаковых объектов - одинаков hashCode 

</details>

<details>
  <summary>7) Ответ</summary>
Поч то не помню окончательный но у меня запись такая 

Используйте разные простые алгоритмы:
Используйте различные алгоритмы для вычисления хэш-кода разных типов объектов.
Например, для строк можно использовать алгоритмы, такие как djb2 или Jenkins.

Переопределите метод `equals`:
При переопределении метода `equals` также переопределите метод `hashCode` таким образом, чтобы он возвращал одинаковое значение для двух объектов, которые считаются равными.
Это поможет избежать коллизий при использовании объектов в коллекциях, которые используют хэш-таблицы, такие как `HashMap` или `HashSet`.

p.S hash поля можно умножать - желательно на простые числа 

</details>

## abstract
1) Какая роль abstract? 
2) Разрешен ли синтаксис конструктора в abstract? Если да - его роль ? 
3) Обязателен ли определение методов интерфейса внтури abstract - чем это обусловленно ? 

<details>
  <summary>1) Ответ</summary>

Вот честнок - сам не знаю 
Ответил типа "Если нужен родительский класс и мы не хотим чтобы его реализовывали"
Поступила жалоба "И всё?"
Закономерный ответ "ДА"

Может еще для чего я просто не знаю
</details>

<details>
  <summary>2) Ответ</summary>

Ну да собсна почему нет - мы не можем релизоват объект от этого класса - но можем задать поля по умлочанию у дочерей 
Не вижу проблем - мб слепой
</details>

<details>
  <summary>3) Ответ</summary>
Кста супер необязательно - Поч ? 

Ну тип interface - это другими словами контракт, контракт который обязует нас во всех объектах реализованных от класса определить метол
Нет объекта - нет и определения

Тип мы же не можем реализовать объект от abstact класса - поэтому и реализовать методы вроде и не надо
</details>

## lambda

1) Почему данный код не будет работать ?
2) Что нужно сделать чтобы код работал ?
3) Какими должны быть переменные внутри lambda ?
4) Можно ли переопределить логику работы lambda ?
5) Что такое effectively final?
```java
class Main {

    protected static int z = 50;

    public static void main(String[] args) {
        int x = 10;
        FunctionalInterface ff
                = () -> System.out.println("Value of x : " + x);

        x++;



        int y = 20;
        ff = () -> System.out.println("Value of y : " + y);
        ff.method();
        z++;
        ff = () -> System.out.println("Value of z : " + z);
        ff.method();
    }
}
```


<details>
  <summary>1) Ответ</summary>

Беда с x - ее нельзя трогать после lambda 
Не очень понял почему - есть очень умное объяснение которое можно найти в инете
</details>
<details>
  <summary>2) Ответ</summary>

Использовать final или effectively final
</details>
<details>
  <summary>3) Ответ</summary>

final или effectively final
</details>
<details>
  <summary>4) Ответ</summary>

Как мы видим с примером y то всё ок - логику работы можно менять

</details>
<details>
  <summary>5) Ответ</summary>

Смех и грех - но похоже на const в питоне - она вроде final а вроде нет

Ну то есть переменная - которая в явном виде не объявлена как final но менять ее знаение запрещено 

</details>
